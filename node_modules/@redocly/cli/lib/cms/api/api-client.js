"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReuniteApiClient = exports.ReuniteApiError = void 0;
const FormData = require("form-data");
const fetch_with_timeout_1 = require("../../utils/fetch-with-timeout");
class ReuniteApiError extends Error {
    constructor(message, status) {
        super(message);
        this.status = status;
    }
}
exports.ReuniteApiError = ReuniteApiError;
class ReuniteBaseApiClient {
    constructor(version, command) {
        this.version = version;
        this.command = command;
    }
    async getParsedResponse(response) {
        const responseBody = await response.json();
        if (response.ok) {
            return responseBody;
        }
        throw new ReuniteApiError(`${responseBody.title || response.statusText || 'Unknown error'}.`, response.status);
    }
    request(url, options) {
        const headers = {
            ...options.headers,
            'user-agent': `redocly-cli/${this.version.trim()} ${this.command}`,
        };
        return (0, fetch_with_timeout_1.default)(url, {
            ...options,
            headers,
        });
    }
}
class RemotesApiClient extends ReuniteBaseApiClient {
    constructor(domain, apiKey, version, command) {
        super(version, command);
        this.domain = domain;
        this.apiKey = apiKey;
    }
    async getDefaultBranch(organizationId, projectId) {
        try {
            const response = await this.request(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/source`, {
                timeout: fetch_with_timeout_1.DEFAULT_FETCH_TIMEOUT,
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${this.apiKey}`,
                },
            });
            const source = await this.getParsedResponse(response);
            return source.branchName;
        }
        catch (err) {
            const message = `Failed to fetch default branch. ${err.message}`;
            if (err instanceof ReuniteApiError) {
                throw new ReuniteApiError(message, err.status);
            }
            throw new Error(message);
        }
    }
    async upsert(organizationId, projectId, remote) {
        try {
            const response = await this.request(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/remotes`, {
                timeout: fetch_with_timeout_1.DEFAULT_FETCH_TIMEOUT,
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${this.apiKey}`,
                },
                body: JSON.stringify({
                    mountPath: remote.mountPath,
                    mountBranchName: remote.mountBranchName,
                    type: 'CICD',
                    autoMerge: true,
                }),
            });
            return await this.getParsedResponse(response);
        }
        catch (err) {
            const message = `Failed to upsert remote. ${err.message}`;
            if (err instanceof ReuniteApiError) {
                throw new ReuniteApiError(message, err.status);
            }
            throw new Error(message);
        }
    }
    async push(organizationId, projectId, payload, files) {
        const formData = new FormData();
        formData.append('remoteId', payload.remoteId);
        formData.append('commit[message]', payload.commit.message);
        formData.append('commit[author][name]', payload.commit.author.name);
        formData.append('commit[author][email]', payload.commit.author.email);
        formData.append('commit[branchName]', payload.commit.branchName);
        payload.commit.url && formData.append('commit[url]', payload.commit.url);
        payload.commit.namespace && formData.append('commit[namespaceId]', payload.commit.namespace);
        payload.commit.sha && formData.append('commit[sha]', payload.commit.sha);
        payload.commit.repository && formData.append('commit[repositoryId]', payload.commit.repository);
        payload.commit.createdAt && formData.append('commit[createdAt]', payload.commit.createdAt);
        for (const file of files) {
            formData.append(`files[${file.path}]`, file.stream);
        }
        payload.isMainBranch && formData.append('isMainBranch', 'true');
        try {
            const response = await this.request(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/pushes`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                },
                body: formData,
            });
            return await this.getParsedResponse(response);
        }
        catch (err) {
            const message = `Failed to push. ${err.message}`;
            if (err instanceof ReuniteApiError) {
                throw new ReuniteApiError(message, err.status);
            }
            throw new Error(message);
        }
    }
    async getRemotesList({ organizationId, projectId, mountPath, }) {
        try {
            const response = await this.request(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/remotes?filter=mountPath:/${mountPath}/`, {
                timeout: fetch_with_timeout_1.DEFAULT_FETCH_TIMEOUT,
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${this.apiKey}`,
                },
            });
            return await this.getParsedResponse(response);
        }
        catch (err) {
            const message = `Failed to get remote list. ${err.message}`;
            if (err instanceof ReuniteApiError) {
                throw new ReuniteApiError(message, err.status);
            }
            throw new Error(message);
        }
    }
    async getPush({ organizationId, projectId, pushId, }) {
        try {
            const response = await this.request(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/pushes/${pushId}`, {
                timeout: fetch_with_timeout_1.DEFAULT_FETCH_TIMEOUT,
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${this.apiKey}`,
                },
            });
            return await this.getParsedResponse(response);
        }
        catch (err) {
            const message = `Failed to get push status. ${err.message}`;
            if (err instanceof ReuniteApiError) {
                throw new ReuniteApiError(message, err.status);
            }
            throw new Error(message);
        }
    }
}
class ReuniteApiClient {
    constructor({ domain, apiKey, version, command, }) {
        this.remotes = new RemotesApiClient(domain, apiKey, version, command);
    }
}
exports.ReuniteApiClient = ReuniteApiClient;
